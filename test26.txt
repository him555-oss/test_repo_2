name: Mirror to Bitbucket (--mirror, destructive)

on:
  workflow_dispatch:

jobs:
  mirror:
    runs-on: ubuntu-latest
    env:
      GH_OWNER: him555-oss        # ชื่อบัญชี GitHub (user หรือ org)
      GH_IS_USER: "true"          # "true" = user, "false" = org
      BB_WORKSPACE: santichaina   # Workspace ID (ตัวพิมพ์เล็ก)
      EXTRA_REPOS: "test-replicate-to-bitbucket"  # ชื่อที่อยากบังคับใส่เพิ่ม (จะมีหรือไม่มี ก็ไม่เป็นไร)

    steps:
      - name: Install jq
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Setup SSH for Bitbucket
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.ssh"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$HOME/.ssh/id_rsa"
          chmod 600 "$HOME/.ssh/id_rsa"
          ssh-keyscan bitbucket.org >> "$HOME/.ssh/known_hosts"

      - name: Who am I on Bitbucket SSH
        shell: bash
        run: ssh -T git@bitbucket.org || true

      # ดึงลิสต์รีโปจาก GitHub → repos.txt (ตัด fork/archived ออก) + เติม EXTRA_REPOS
      - name: Build repos.txt
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          GH_PAT="$(printf '%s' "${GH_TOKEN:-}" | tr -d '\r\n')"
          if [ -z "${GH_PAT}" ]; then echo "ERROR: GH_TOKEN missing"; exit 1; fi

          : > repos.txt
          page=1
          while :; do
            if [ "${GH_IS_USER}" = "true" ]; then
              url="https://api.github.com/users/${GH_OWNER}/repos?per_page=100&page=${page}&type=owner"
            else
              url="https://api.github.com/orgs/${GH_OWNER}/repos?per_page=100&page=${page}&type=source"
            fi
            resp="$(curl -sS -H "Authorization: Bearer ${GH_PAT}" -H "Accept: application/vnd.github+json" "$url")"
            if ! echo "$resp" | jq -e 'type=="array"' >/dev/null; then
              echo "GitHub API error:"; echo "$resp" | jq . || echo "$resp"; exit 1
            fi
            count="$(echo "$resp" | jq 'length')"
            [ "$count" -eq 0 ] && break
            echo "$resp" | jq -r 'map(select(.fork==false) | select(.archived==false)) | .[].name' >> repos.txt
            [ "$count" -lt 100 ] && break
            page=$((page+1))
          done
          for r in ${EXTRA_REPOS}; do [ -n "$r" ] && echo "$r" >> repos.txt || true; done
          sort -u -o repos.txt repos.txt
          echo "repos.txt (first 100):"; nl -ba repos.txt | sed -n '1,100p'
          [ -s repos.txt ] || { echo "ERROR: repos.txt empty"; exit 1; }

      - name: Upload repos.txt (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: repos.txt
          path: repos.txt

      - name: Mirror with DELETION (--mirror)
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          GH_PAT="$(printf '%s' "${GH_TOKEN:-}" | tr -d '\r\n')"

          while IFS= read -r REPO || [ -n "$REPO" ]; do
            [ -n "$REPO" ] || continue
            SLUG="$(echo "$REPO" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')"
            BB_URL="git@bitbucket.org:${BB_WORKSPACE}/${SLUG}.git"
            echo ">>> $REPO -> $BB_URL"

            # ปลายทางต้องเข้าถึงได้ (ไม่มี auto-create ในไฟล์นี้)
            if ! git ls-remote "$BB_URL" >/dev/null 2>&1; then
              echo "Skip: $BB_URL not accessible"; continue
            fi

            SRC="https://x-access-token:${GH_PAT}@github.com/${GH_OWNER}/${REPO}.git"
            rm -rf "${REPO}.git"
            if ! git clone --mirror "$SRC" "${REPO}.git"; then
              echo "Clone failed: $REPO"; continue
            fi

            (
              cd "${REPO}.git"
              git remote add bitbucket "$BB_URL" 2>/dev/null || git remote set-url bitbucket "$BB_URL"

              # แสดง “รายการที่จะโดนลบ” ล่วงหน้า (target-only heads/tags)
              {
                echo "--- Preview deletions (branches) ---"
                LCL_HEADS="$(git for-each-ref --format='%(refname:short)' refs/heads | sort || true)"
                TGT_HEADS="$(git ls-remote --heads "$BB_URL" | sed 's@.*refs/heads/@@' | sort || true)"
                printf "%s\n" "$LCL_HEADS" > /tmp/src_heads.txt
                printf "%s\n" "$TGT_HEADS" > /tmp/tgt_heads.txt
                comm -13 /tmp/src_heads.txt /tmp/tgt_heads.txt || true

                echo "--- Preview deletions (tags) ---"
                LCL_TAGS="$(git for-each-ref --format='%(refname:short)' refs/tags | sort || true)"
                TGT_TAGS="$(git ls-remote --tags "$BB_URL" | sed 's@.*refs/tags/@@' | sed 's/\^{}$//' | sort | uniq || true)"
                printf "%s\n" "$LCL_TAGS" > /tmp/src_tags.txt
                printf "%s\n" "$TGT_TAGS" > /tmp/tgt_tags.txt
                comm -13 /tmp/src_tags.txt /tmp/tgt_tags.txt || true
              } || true

              echo "PUSHING WITH --mirror (destructive)"
              git push --mirror bitbucket || true
            )

            rm -rf "${REPO}.git"
            echo "Done: $REPO"
          done < repos.txt

          echo "Completed."
